cr_patch1$Consumer[1] = C0
cr_patches[[1]] <- cr_patch1
for(t in 1:(t_final-1)) {
current_cluster <- filter(landscape_data, clusters==t)
R1 <- cr_patch1$Resource # for readability
C1 <- cr_patch1$Consumer # for readability
R1[t+1] = R1[t] + a * R1[t] * (1 - R1[t] / K) - b * R1[t] / (A + R1[t]) * C1[t] # Resource AKA FTC dynamics
C1[t+1] = C1[t] + e * ((R1[t] / (A + R1[t])) - (B / (B + A))) * C1[t] # Consumer AKA Fly dynamics
cr_patch1$Resource[t+1] <- R1[t+1]
cr_patch1$Consumer[t+1] <- C1[t+1]
}
# patch 1 CR plot
ggplot(cr_patch1, aes(x = as.numeric(row.names(cr_patch1)))) +
geom_path(aes(y = Resource), colour = "salmon") +
geom_path(aes(y = Consumer), colour = "purple") +
labs(title = "Patch Dynamics", x = "Timestep", y = "Population size") +
theme_minimal() +
theme(legend.position="none")
}
# Parameters
{
n_patches = length(unique(na.omit(landscape_data$clusters))) # Number of patches omitting NAs
t <- 1               # Initial time
t_final <- 200       # number of time steps
R0 <- 60             # Initial FTC in patch
C0 <- 20              # Initial Fly in patch
a <- 3               # Ability of FTC to avoid flies
A <- 50              # FTC half-saturation constant ???
b <- 3               # Fly consumption ability
B <- 33              # Fly half-saturation constant
e <- 0.5             # Extinction rate of the fly
K <- 100             # FTC Carrying capacity
cr_patches <- vector("list", n_patches) # cr series all patches
cr_patch1 <- data.frame(Resource = numeric(t_final), # cr series patch 1
Consumer = numeric(t_final))
cr_patch1$Resource[1] = R0 # Set initials
cr_patch1$Consumer[1] = C0
cr_patches[[1]] <- cr_patch1
for(t in 1:(t_final-1)) {
current_cluster <- filter(landscape_data, clusters==t)
R1 <- cr_patch1$Resource # for readability
C1 <- cr_patch1$Consumer # for readability
R1[t+1] = R1[t] + a * R1[t] * (1 - R1[t] / K) - b * R1[t] / (A + R1[t]) * C1[t] # Resource AKA FTC dynamics
C1[t+1] = C1[t] + e * ((R1[t] / (A + R1[t])) - (B / (B + A))) * C1[t] # Consumer AKA Fly dynamics
cr_patch1$Resource[t+1] <- R1[t+1]
cr_patch1$Consumer[t+1] <- C1[t+1]
}
# patch 1 CR plot
ggplot(cr_patch1, aes(x = as.numeric(row.names(cr_patch1)))) +
geom_path(aes(y = Resource), colour = "salmon") +
geom_path(aes(y = Consumer), colour = "purple") +
labs(title = "Patch Dynamics", x = "Timestep", y = "Population size") +
theme_minimal() +
theme(legend.position="none")
}
# Parameters
{
n_patches = length(unique(na.omit(landscape_data$clusters))) # Number of patches omitting NAs
t <- 1               # Initial time
t_final <- 200       # number of time steps
R0 <- 60             # Initial FTC in patch
C0 <- 20              # Initial Fly in patch
a <- 3               # Ability of FTC to avoid flies
A <- 50              # FTC half-saturation constant ???
b <- 5               # Fly consumption ability
B <- 33              # Fly half-saturation constant
e <- 0.5             # Extinction rate of the fly
K <- 100             # FTC Carrying capacity
cr_patches <- vector("list", n_patches) # cr series all patches
cr_patch1 <- data.frame(Resource = numeric(t_final), # cr series patch 1
Consumer = numeric(t_final))
cr_patch1$Resource[1] = R0 # Set initials
cr_patch1$Consumer[1] = C0
cr_patches[[1]] <- cr_patch1
for(t in 1:(t_final-1)) {
current_cluster <- filter(landscape_data, clusters==t)
R1 <- cr_patch1$Resource # for readability
C1 <- cr_patch1$Consumer # for readability
R1[t+1] = R1[t] + a * R1[t] * (1 - R1[t] / K) - b * R1[t] / (A + R1[t]) * C1[t] # Resource AKA FTC dynamics
C1[t+1] = C1[t] + e * ((R1[t] / (A + R1[t])) - (B / (B + A))) * C1[t] # Consumer AKA Fly dynamics
cr_patch1$Resource[t+1] <- R1[t+1]
cr_patch1$Consumer[t+1] <- C1[t+1]
}
# patch 1 CR plot
ggplot(cr_patch1, aes(x = as.numeric(row.names(cr_patch1)))) +
geom_path(aes(y = Resource), colour = "salmon") +
geom_path(aes(y = Consumer), colour = "purple") +
labs(title = "Patch Dynamics", x = "Timestep", y = "Population size") +
theme_minimal() +
theme(legend.position="none")
}
# Parameters
{
n_patches = length(unique(na.omit(landscape_data$clusters))) # Number of patches omitting NAs
t <- 1               # Initial time
t_final <- 200       # number of time steps
R0 <- 60             # Initial FTC in patch
C0 <- 20              # Initial Fly in patch
a <- 3               # Ability of FTC to avoid flies
A <- 50              # FTC half-saturation constant ???
b <- 5               # Fly consumption ability
B <- 35              # Fly half-saturation constant
e <- 0.5             # Extinction rate of the fly
K <- 100             # FTC Carrying capacity
cr_patches <- vector("list", n_patches) # cr series all patches
cr_patch1 <- data.frame(Resource = numeric(t_final), # cr series patch 1
Consumer = numeric(t_final))
cr_patch1$Resource[1] = R0 # Set initials
cr_patch1$Consumer[1] = C0
cr_patches[[1]] <- cr_patch1
for(t in 1:(t_final-1)) {
current_cluster <- filter(landscape_data, clusters==t)
R1 <- cr_patch1$Resource # for readability
C1 <- cr_patch1$Consumer # for readability
R1[t+1] = R1[t] + a * R1[t] * (1 - R1[t] / K) - b * R1[t] / (A + R1[t]) * C1[t] # Resource AKA FTC dynamics
C1[t+1] = C1[t] + e * ((R1[t] / (A + R1[t])) - (B / (B + A))) * C1[t] # Consumer AKA Fly dynamics
cr_patch1$Resource[t+1] <- R1[t+1]
cr_patch1$Consumer[t+1] <- C1[t+1]
}
# patch 1 CR plot
ggplot(cr_patch1, aes(x = as.numeric(row.names(cr_patch1)))) +
geom_path(aes(y = Resource), colour = "salmon") +
geom_path(aes(y = Consumer), colour = "purple") +
labs(title = "Patch Dynamics", x = "Timestep", y = "Population size") +
theme_minimal() +
theme(legend.position="none")
}
# install.packages("pak")
pak::pak("pedersen-fisheries-lab/eigenmove")
library(eigenmove)
ls(getNamespace("eigenmove"), all.names = TRUE)
library(sf)
library(ggplot2)
create_hex_landscape <- function() {
bbox <- st_bbox(c(xmin = 1, ymin = 1, xmax = 32, ymax = 32)) # Set bounds
hex_grid <- st_make_grid(
st_as_sfc(bbox), # Convert bounding polygon to sfc object
cellsize = 1,        # Size of each cell
square = FALSE,      # Create hexagons instead of squares
what = "polygons"    # We want the actual polygon cells
)
# Convert to sf object and add cell IDs
hex_sf <- st_sf(cell_id = 1:length(hex_grid), geometry = hex_grid)
return(hex_sf)
}
visualise_landscape <- function(landscape){
ggplot() +
geom_sf(data = landscape,
colour = "black",     # Cell border colour
fill = NA,            # No fill
linewidth = 0) +    # Border line width (integers)
labs(title = "Toy Landscape",
x = "Longitude",
y = "Latitude") +
theme_void() # Switch to theme_minimal if you want to see labels
}
source("code/mapping.R")
# Generate the landscape
landscape <- create_hex_landscape()
# Visualise the landscape
landscape_plot <- visualise_landscape(landscape)
landscape_plot
source("code/mapping.R")
# Generate the landscape
landscape <- create_hex_landscape()
# Visualise the landscape
landscape_plot <- visualise_landscape(landscape)
landscape_plot
View(landscape)
# Pick 7 central hexes and mark as good habitat
center_ids <- c(27, 28, 29, 35, 36, 37, 43)  # adjust as needed
View(landscape)
landscape$habitat <- ifelse(landscape$cell_id %in% center_ids, "good", "bad")
# Re-plot with fill colour
ggplot() +
geom_sf(data = landscape, aes(fill = habitat), colour = "black", linewidth = 0) +
scale_fill_manual(values = c("good" = "black", "bad" = "white")) +
theme_void()
# Pick 7 central hexes and mark as good habitat
center_ids <- c(33, 38, 39, 43, 48, 49, 53)  # adjust as needed
landscape$habitat <- ifelse(landscape$cell_id %in% center_ids, "good", "bad")
# Re-plot with fill colour
ggplot() +
geom_sf(data = landscape, aes(fill = habitat), colour = "black", linewidth = 0) +
scale_fill_manual(values = c("good" = "black", "bad" = "white")) +
theme_void()
center_ids
View(landscape)
# Generate the landscape
landscape <- create_hex_landscape()
# Pick 7 central hexes and mark as good habitat
center_ids <- c(33, 38, 39, 43, 48, 49, 53)  # adjust as needed
landscape$habitat <- ifelse(landscape$cell_id %in% center_ids, "good", "bad")
ggplot() + # visualise
geom_sf(data = landscape, aes(fill = habitat), colour = "black", linewidth = 0) +
scale_fill_manual(values = c("good" = "black", "bad" = "white")) +
theme_void()
source("code/model.R")
pre_host_size <- list()
source("code/model.R")
# Host growth equation
host_growth <- function(pre_host_size,
intrinsic_host_growth,
pre_host_size,
pre_parasitoid_growth,
attack_rate)
{
host_size <-
intrinsic_host_growth *
pre_host_size *
exp(-log(intrinsic_host_growth) * pre_host_size) *
exp(-pre_parasitoid_growth * attack_rate)
}
# Parameters
params <- list(lambda = 3, # intrinsic growth rate
a = 0.2, # parasitoid attack rate
timesteps = 50)
# Setup
n_cells <- nrow(landscape)
H <- matrix(0, nrow = params$timesteps, ncol = n_cells)
H
# 1. Centroids and distances
centroids <- st_coordinates(st_centroid(landscape))
centroids
# 1. Centroids and distances
centroids <- st_coordinates(st_centroid(landscape))
dist_mat <- as.matrix(dist(centroids))
dist_mat
# Generate the landscape
landscape <- create_hex_landscape()
centroids <- st_coordinates(st_centroid(landscape))
dist_mat <- as.matrix(dist(centroids))
dist_mat
# 2. Dispersal kernel matrix
d_bar_x <- 1.5
# 1. Dispersal kernel matrix
d_bar_x <- 1.5
K <- dispersal_kernel(dist_mat, d_bar_x)
source("code/model.R")
K <- dispersal_kernel(dist_mat, d_bar_x)
K <- K / rowSums(K)  # normalize rows
K
dist_mat
# 3. Initial host distribution
H <- rep(0, nrow(landscape))
H
H[30] <- 1
# 3. Initial host distribution
H <- rep(0, nrow(landscape))
H[43] <- 1
# 4. Apply dispersal
H_next <- K %*% H
# 5. Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c()
H[1] <- 1
# 4. Apply dispersal
H_next <- K %*% H
# 5. Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c()
H[85] <- 1
# 4. Apply dispersal
H_next <- K %*% H
# 5. Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c()
H[1] <- 1
# 4. Apply dispersal
H_next <- K %*% H
# 5. Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c()
# 3. Initial host distribution
H <- rep(0, nrow(landscape))
H[43] <- 1
H[1] <- 1
# 4. Apply dispersal
H_next <- K %*% H
# 5. Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c()
# Sparsify dispersal
sparse_kernel <- function(landscape, d_bar_x, maxdist_mult = 4) {
coords <- st_coordinates(st_centroid(landscape))
n <- nrow(coords)
maxdist <- maxdist_mult * d_bar_x
# neighbors within maxdist (excludes self)
nb <- dnearneigh(coords, 0, maxdist, longlat = FALSE)
# build pair lists (include self as destination)
rows <- rep(seq_len(n), lengths(nb) + 1)    # +1 for self
cols <- unlist(lapply(seq_len(n), function(i) c(i, nb[[i]])))
# compute distances for those pairs
diffxy <- coords[rows, , drop = FALSE] - coords[cols, , drop = FALSE]
dists <- sqrt(rowSums(diffxy * diffxy))
# compute kernel weights (no row normalization -> absorbing)
weights <- dispersal_kernel(dists, d_bar_x)
# assemble sparse matrix (rows = origin, cols = destination)
K <- sparseMatrix(i = rows, j = cols, x = weights, dims = c(n, n))
return(K)   # rows may sum < 1 => absorbing outflow
}
?dnearneigh
??dnearneigh
library(sf)
library(spdep)
library(Matrix)
?dnearneigh
nb <- dnearneigh(x = coords, d1 = 0, d2 = maxdist, longlat = FALSE) # only consider those within range
maxdist <- maxdist_mult * d_bar_x # max dispersal distance
maxdist_mult = 4
maxdist <- maxdist_mult * d_bar_x # max dispersal distance
d_bar_x <- 1.5
maxdist <- maxdist_mult * d_bar_x # max dispersal distance
coords <- st_coordinates(st_centroid(landscape)) # Set coordinates to cell centroids
seq_len(n)
n=10
seq_len(n)
1:n
lengths(n)
?lengths
length(n)
# build pair lists (include self as destination)
rows <- rep(1:n, length(nb) + 1)    # +1 for self
nb <- dnearneigh(x = coords, d1 = 0, d2 = maxdist, longlat = FALSE) # only consider those within range
# build pair lists (include self as destination)
rows <- rep(1:n, length(nb) + 1)    # +1 for self
source("code/model.R")
# Generate the landscape
landscape <- create_hex_landscape()
source("code/mapping.R")
source("code/model.R")
# Generate the landscape
landscape <- create_hex_landscape()
centroids <- st_coordinates(st_centroid(landscape))
dist_mat <- as.matrix(dist(centroids))
# Dispersal
debugonce(build_sparse_kernel)
# Dispersal
debugonce(sparse_kernel)
K <- sparse_kernel(landscape, d_bar_x = 1.5)
# Dispersal
debugonce(sparse_kernel)
K <- sparse_kernel(landscape, d_bar_x = 1.5)
# Dispersal
debugonce(sparse_kernel)
K <- sparse_kernel(landscape, d_bar_x = 1.5)
# Dispersal
debugonce(sparse_kernel)
K <- sparse_kernel(landscape, d_bar_x = 1.5)
length(rows)
length(cols)
length(rows)
# Dispersal
debugonce(sparse_kernel)
K <- sparse_kernel(landscape, d_bar_x = 1.5)
source("code/model.R")
K <- sparse_kernel(landscape, d_bar_x = 1.5)
source("code/model.R")
K <- sparse_kernel(landscape, d_bar_x = 1.5)
source("code/model.R")
K <- sparse_kernel(landscape, d_bar_x = 1.5)
n=10
1:n
seq_len(n)
?rep
?sapply
# Example usage:
# landscape <- create_hex_landscape()
# K_sparse <- build_sparse_kernel(landscape, d_bar_x = 1.5, maxdist_mult = 4)
# H <- numeric(nrow(landscape)); H[30] <- 1
# H_next <- as.numeric(K_sparse %*% H)
#
nb <- list(
c(2, 3),  # neighbors of cell 1
c(1),     # neighbors of cell 2
integer(0) # neighbors of cell 3
)
n <- length(nb)
nb
n <- length(nb)
n
lapply(X = seq_len(n), FUN = function(i) { i })
?unlist
source("code/model.R")
source("code/mapping.R")
source("code/model.R")
# Generate the landscape
landscape <- create_hex_landscape()
centroids <- st_coordinates(st_centroid(landscape))
dist_mat <- as.matrix(dist(centroids))
K <- sparse_kernel(landscape, d_bar_x = 1.5)
source("code/model.R")
K <- sparse_kernel(landscape, d_bar_x = 1.5)
cols
rows
source("code/model.R")
source("code/model.R")
K <- sparse_kernel(landscape, d_bar_x = 1.5)
source("code/model.R")
K <- sparse_kernel(landscape, d_bar_x = 1.5)
# 3. Initial host distribution
H <- rep(0, nrow(landscape))
H[43] <- 1
# 4. Apply dispersal
H_next <- K %*% H
# 5. Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c()
H[1] <- 1
# 4. Apply dispersal
H_next <- K %*% H
# 5. Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c()
ggplot() + # visualise
geom_sf(data = landscape, aes(fill = habitat), colour = "black", linewidth = 0) +
scale_fill_manual(values = c("good" = "black", "bad" = "white")) +
theme_void()
source("code/mapping.R")
source("code/model.R")
# Generate the landscape
landscape <- create_hex_landscape()
centroids <- st_coordinates(st_centroid(landscape))
dist_mat <- as.matrix(dist(centroids))
visualise_landscape
g <- visualise_landscape()
g <- visualise_landscape(landscape)
g
# Generate the landscape
landscape <- create_hex_landscape()
centroids <- st_coordinates(st_centroid(landscape))
dist_mat <- as.matrix(dist(centroids))
# Dispersal
K <- sparse_kernel(landscape, d_bar_x = 1.5)
# 3. Initial host distribution
H <- rep(0, nrow(landscape))
H[43] <- 1
H[1] <- 1
# 4. Apply dispersal
H_next <- K %*% H
# 5. Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c()
# Generate the landscape
landscape <- create_hex_landscape()
centroids <- st_coordinates(st_centroid(landscape))
source("code/mapping.R")
source("code/model.R")
# Generate the landscape
landscape <- create_hex_landscape()
centroids <- st_coordinates(st_centroid(landscape))
dist_mat <- as.matrix(dist(centroids))
# Initialize host distribution
H <- rep(0, nrow(landscape))
H[43] <- 1
H[1] <- 1
source("code/mapping.R")
source("code/model.R")
# Generate and process the landscape
landscape <- create_hex_landscape()
centroids <- st_coordinates(st_centroid(landscape))
dist_mat <- as.matrix(dist(centroids))
# Generate sparse dispersal kernel
K <- sparse_kernel(landscape, d_bar_x = 1.5)
# Initialize host distribution
H <- rep(0, nrow(landscape))
H[43] <- 1
H[1] <- 1
# Disperse
H_next <- K %*% H
# Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c()
c(H[43],H[1]) <- c(1,1)
# Initialize host distribution
H <- rep(0, nrow(landscape))
H[c(1, 33, 38, 39, 43)] <- 1
# Disperse
H_next <- K %*% H
# Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c()
source("code/mapping.R")
source("code/model.R")
install.packages("spdep")
source("code/mapping.R")
source("code/model.R")
# Generate and process the landscape
landscape <- create_hex_landscape()
centroids <- st_coordinates(st_centroid(landscape))
dist_mat <- as.matrix(dist(centroids))
# Generate sparse dispersal kernel
K <- sparse_kernel(landscape, d_bar_x = 1.5)
# Initialize host distribution
H <- rep(0, nrow(landscape))
H[c(1, 33, 38, 39, 43)] <- 1
# Disperse
H_next <- K %*% H
# Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c()
H[c(1, 43)] <- 1
# Initialize host distribution
H <- rep(0, nrow(landscape))
H[c(1, 43)] <- 1
# Disperse
H_next <- K %*% H
# Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c()
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c() + theme_minimal()
ggplot(landscape) + geom_sf(aes(fill = H)) + scale_fill_viridis_c() + theme_void()
