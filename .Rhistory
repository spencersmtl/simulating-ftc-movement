ggplot(landscape) +
geom_sf(aes(fill = H)) +
scale_fill_viridis_c() +
theme_void()
ggplot(landscape) +
geom_sf(aes(fill = H_next)) +
scale_fill_viridis_c() +
theme_void()
# Initialize host distribution
H <- rep(0, nrow(landscape))
H[c(6)] <- 1
# Disperse
H_next <- K %*% H
# Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) +
geom_sf(aes(fill = H)) +
scale_fill_viridis_c() +
theme_void()
H
H_next
K
# Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) +
geom_sf(aes(fill = H)) +
scale_fill_viridis_c() +
theme_void()
landscape
H_next
K
H
K
load_landscape <- function(png, scale = 1, cellsize = 8) {
# Load and scale
img <- imager::load.image(png) # load image
if (!is.numeric(scale) || scale <= 0) stop("scale must be > 0") # basic scale requirement
if (scale != 1) img <- imager::imresize(img, scale) # rescale image if specified. Higher is bigger
browser()
# Turn into dataframe and process
pixel_df <- as.data.frame(img) |>
group_by(x, y) |>
summarize(value = mean(value, na.rm = TRUE), # get mean RGBO of each pixel
.groups = "drop") |>
mutate(y = max(y) - y + 1) # flip image right side up
# Turn into hex grid
point_geometry <- st_as_sf(pixel_df, coords = c("x", "y"), crs = NA) # points as sf pixel cartesian coordinates
bbox_sfc <- st_as_sfc(st_bbox(point_geometry)) # pixel bounding box
bbox_exp <- st_buffer(bbox_sfc, dist = 1e-5) # tiny buffer to avoid edge issues
hex_grid <- st_make_grid(   # Make a hex grid over the bounding box
bbox_exp,
cellsize = cellsize,
square = FALSE,
what = "polygons")
inside <- st_within(st_centroid(hex_grid), bbox_sfc, sparse = FALSE)   # specify only hexes fully inside the image area
hex_grid_full <- hex_grid[inside, ] # keep specified hexes
hex_sf <- st_sf(cell_id = seq_along(hex_grid_full), geometry = hex_grid_full) # Convert to sf and assign cell IDs
pts_to_hex <- st_join(pts, hex_sf, join = st_intersects) # assign all pixels to hexes
# Make sure scale/cellsize is appropriate
counts <- tabulate(pts_to_hex$cell_id, nbins = nrow(hex_sf)) # Count how many pixels were assigned to each hex
empty_frac <- mean(counts == 0) # Count how many empty hexes there are
if (empty_frac > 0.01) {stop(sprintf(
"cellsize too small for this image: %.1f%% of hexes contain no pixels. Increase cellsize or increase scale factor.",
empty_frac * 100))}
# Quantify hexes based on pixel values for optional modeling use later (e.g., habitat quality)
hex_vals <- pts_to_hex |> # hex_vals is an sf of aggregated points with geometries
group_by(cell_id) |>
summarize(value = mean(value, na.rm = TRUE), .groups = "drop") # get mean value of hexes
hex_vals_df <- sf::st_set_geometry(hex_vals, NULL)   # plain df to use left_join
hex_sf <- dplyr::left_join(hex_sf, hex_vals_df, by = "cell_id") # add values to hex_sf
hex_sf$value[is.na(hex_sf$value)] <- 1   # set NAs to base habitat type
# Set habitat qualities
hex_sf$type <- dplyr::case_when( # set habitat types
hex_sf$value > 0.5 ~ "low", # add more mean RGBO cases here
hex_sf$value <= 0.5 ~ "high") |>
factor(levels = c("low", "high"))
# Compute centroids of cells
cents <- st_coordinates(st_centroid(hex_sf))
hex_sf$centroid_x <- cents[,1]
hex_sf$centroid_y <- cents[,2]
# Compute raw spacing between any adjacent hexes
neighbors <- st_touches(hex_sf)
i <- 1
j <- neighbors[[i]][1]
raw_adj <- sqrt(sum((cents[i, ] - cents[j, ])^2))
# Normalize centroid coordinates so adjacent spacing = 1
hex_sf$centroid_x <- hex_sf$centroid_x / raw_adj
hex_sf$centroid_y <- hex_sf$centroid_y / raw_adj
return(hex_sf)
}
landscape <- load_landscape("images/blobs.png",
scale = 0.5,# Set scale <1 to shrink image
cellsize = 80) # set cellsize <8 to make a finer hex grid overlay
load_landscape <- function(png, scale = 1, cellsize = 8) {
# Load and scale
img <- imager::load.image(png) # load image
if (!is.numeric(scale) || scale <= 0) stop("scale must be > 0") # basic scale requirement
if (scale != 1) img <- imager::imresize(img, scale) # rescale image if specified. Higher is bigger
browser()
# Turn into dataframe and process
pixel_df <- as.data.frame(img) |>
group_by(x, y) |>
summarize(value = mean(value, na.rm = TRUE), # get mean RGBO of each pixel
.groups = "drop") |>
mutate(y = max(y) - y + 1) # flip image right side up
# Turn into hex grid
point_geometry <- st_as_sf(pixel_df, coords = c("x", "y"), crs = NA) # points as sf pixel cartesian coordinates
bbox_sfc <- st_as_sfc(st_bbox(point_geometry)) # pixel bounding box
bbox_exp <- st_buffer(bbox_sfc, dist = 1e-5) # tiny buffer to avoid edge issues
hex_grid <- st_make_grid(   # Make a hex grid over the bounding box
bbox_exp,
cellsize = cellsize,
square = FALSE,
what = "polygons")
inside <- st_within(st_centroid(hex_grid), bbox_sfc, sparse = FALSE)   # specify only hexes fully inside the image area
hex_grid_full <- hex_grid[inside, ] # keep specified hexes
hex_sf <- st_sf(cell_id = seq_along(hex_grid_full), geometry = hex_grid_full) # Convert to sf and assign cell IDs
pts_to_hex <- st_join(pts, hex_sf, join = st_intersects) # assign all pixels to hexes
# Make sure scale/cellsize is appropriate
counts <- tabulate(pts_to_hex$cell_id, nbins = nrow(hex_sf)) # Count how many pixels were assigned to each hex
empty_frac <- mean(counts == 0) # Count how many empty hexes there are
if (empty_frac > 0.01) {stop(sprintf(
"cellsize too small for this image: %.1f%% of hexes contain no pixels. Increase cellsize or increase scale factor.",
empty_frac * 100))}
# Quantify hexes based on pixel values for optional modeling use later (e.g., habitat quality)
hex_vals <- pts_to_hex |> # hex_vals is an sf of aggregated points with geometries
group_by(cell_id) |>
summarize(value = mean(value, na.rm = TRUE), .groups = "drop") # get mean value of hexes
hex_vals_df <- sf::st_set_geometry(hex_vals, NULL)   # plain df to use left_join
hex_sf <- dplyr::left_join(hex_sf, hex_vals_df, by = "cell_id") # add values to hex_sf
hex_sf$value[is.na(hex_sf$value)] <- 1   # set NAs to base habitat type
# Set habitat qualities
hex_sf$type <- dplyr::case_when( # set habitat types
hex_sf$value > 0.5 ~ "low", # add more mean RGBO cases here
hex_sf$value <= 0.5 ~ "high") |>
factor(levels = c("low", "high"))
# Compute centroids of cells
cents <- st_coordinates(st_centroid(hex_sf))
hex_sf$centroid_x <- cents[,1]
hex_sf$centroid_y <- cents[,2]
# Compute raw spacing between any adjacent hexes
neighbors <- st_touches(hex_sf)
i <- 1
j <- neighbors[[i]][1]
raw_adj <- sqrt(sum((cents[i, ] - cents[j, ])^2))
# Normalize centroid coordinates so adjacent spacing = 1
hex_sf$centroid_x <- hex_sf$centroid_x / raw_adj
hex_sf$centroid_y <- hex_sf$centroid_y / raw_adj
return(hex_sf)
}
landscape <- load_landscape("images/blobs.png",
scale = 0.5,# Set scale <1 to shrink image
cellsize = 80) # set cellsize <8 to make a finer hex grid overlay
getOption("keep.source")
getOption("keep.source")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
library(dplyr)
library(sf)
source("~/.active-rstudio-document")
View(point_geometry)
source("~/.active-rstudio-document")
View(point_geometry)
View(bbox_sfc)
bbox_sfc[[1]][[1]]
?bbox_sfc
?st_bbox
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
View(hex_grid)
View(inside)
source("~/.active-rstudio-document")
View(hex_sf)
source("~/.active-rstudio-document")
View(pts_to_hex)
512*512
View(point_geometry)
256^2
View(pts_to_hex)
View(pts_to_hex)
sum(is.na(pts_to_hex))
65536/17110
?sprintf
?paste
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
na_count
na_count/nrow(pts_to_hex)
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
View(hex_sf)
View(landscape)
View(landscape)
source("~/.active-rstudio-document")
View(hex_vals)
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
View(hex_vals)
?st_join
View(pts_to_hex)
source("~/.active-rstudio-document")
View(hex_vals)
source("~/.active-rstudio-document")
View(hex_vals)
View(hex_sf)
?left_join
band_members %>% inner_join(band_instruments)
band_members %>% inner_join(band_instruments)
band_members
band_members
band_instruments
?band_members
band_members
band_instruments
band_members %>% inner_join(band_instruments)
band_members %>% left_join(band_instruments)
band_members %>% right_join(band_instruments)
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
View(hex_vals)
View(hex_vals)
View(hex_sf)
View(hex_vals)
?as.data.frame
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
View(hex_sf)
View(hex_sf)
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
View(landscape)
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
View(landscape)
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
View(hex_vals)
as.data.frame(hex_vals)
as.data.frame(hex_vals)$value
?append
?cbind
?st_join
View(landscape)
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
View(landscape)
basic_habitat_quality <- function(landscape, threshold = 0.5){
# Set habitat qualities
landscape$type <- case_when( # set habitat types
landscape$value > threshold ~ "low", # add more mean RGBO cases here
landscape$value <= threshold ~ "high") |>
factor(levels = c("low", "high"))
}
habitat_landscape <- basic_habitat_quality(landscape, threshold = 0.5)
View(landscape)
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
View(landscape)
source("~/R/simulating-ftc-movement/code/temp_habitatquals.R")
View(habitat_landscape)
source("code/mapping.R")
source("code/model.R")
# Load an image as landscape
landscape <- load_landscape("images/blobs.png",
scale = 0.5,# Set scale <1 to shrink image
cellsize = 80) # set cellsize <8 to make a finer hex grid overlay
# Load an image as landscape
landscape <- load_landscape("images/blobs.png",
scale = 0.5,# Set scale <1 to shrink image
cellsize = 100) # set cellsize <8 to make a finer hex grid overlay
visualise_landscape(landscape)
# Load an image as landscape
landscape <- load_landscape(
"images/blobs.png",
scale = 0.5,# Set scale <1 to shrink image
cellsize = 100) |> # set cellsize <8 to make a finer hex grid overlay
basic_habitat_quality(threshold = 0.5)
visualise_landscape(landscape)
# Load an image as landscape
landscape <- load_landscape(
"images/blobs.png",
scale = 0.5,# Set scale <1 to shrink image
cellsize = 10) |> # set cellsize <8 to make a finer hex grid overlay
basic_habitat_quality(threshold = 0.5)
visualise_landscape(landscape)
# Load an image as landscape
landscape <- load_landscape(
"images/blobs.png",
scale = 0.5,# Set scale <1 to shrink image
cellsize = 20) |> # set cellsize <8 to make a finer hex grid overlay
basic_habitat_quality(threshold = 0.5)
visualise_landscape(landscape)
# Load an image as landscape
landscape <- load_landscape(
"images/blobs.png",
scale = 0.5,# Set scale <1 to shrink image
cellsize = 50) |> # set cellsize <8 to make a finer hex grid overlay
basic_habitat_quality(threshold = 0.5)
visualise_landscape(landscape)
# Load an image as landscape
landscape <- load_landscape(
"images/blobs.png",
scale = 0.5,# Set scale <1 to shrink image
cellsize = 100) |> # set cellsize <8 to make a finer hex grid overlay
basic_habitat_quality(threshold = 0.5)
visualise_landscape(landscape)
source("code/mapping.R")
source("code/model.R")
# Load an image as landscape
landscape <- load_landscape(
"images/blobs.png",
scale = 0.5,# Set scale <1 to shrink image
cellsize = 100) |> # set cellsize <8 to make a finer hex grid overlay
basic_habitat_quality(threshold = 0.5)
visualise_landscape(landscape)
View(landscape)
source("code/mapping.R")
# Load an image as landscape
landscape <- load_landscape(
"images/blobs.png",
scale = 0.5,# Set scale <1 to shrink image
cellsize = 100) |> # set cellsize <8 to make a finer hex grid overlay
basic_habitat_quality(threshold = 0.5)
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
force(landscape)
force(d_bar_x)
View(landscape)
?st_distance
View(landscape)
sqrt(
(landscape$centroid_x[1]-landscape$centroid_x[2])^2 +
(landscape$centroid_y[1]-landscape$centroid_y[2])
)
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
force(avg_host_dispersal)
force(landscape)
force(max_host_dispersal_mult)
force(normalize_rows)
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
View(landscape)
View(landscape)
str(landscape)
str(landscape$geometry)
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
force(landscape)
force(avg_host_dispersal)
force(max_host_dispersal_mult)
force(normalize_rows)
View(landscape)
?dist
dist(landscape[1:2,])
View(landscape)
sqrt(
(landscape$centroid_x[1] - landscape$centroid_x[2])^2 +
(landscape$centroid_y[1] - landscape$centroid_y[2])^2 )
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
force(avg_host_dispersal)
force(max_host_dispersal_mult)
force(normalize_rows)
coords <- landscape[, c("centroid_x", "centroid_y")]
View(coords)
st_centroid(landscape)
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
View(landscape)
st_centroid(landscape)
coords <- landscape[, c("centroid_x", "centroid_y")]
pts <- st_as_sf(landscape, coords = c("centroid_x", "centroid_y"))
st_distance(pts[1, ], pts[2, ])
View(pts)
View(landscape)
coords <- st_coordinates(landscape)   # centroid coordinates
View(coords)
st_centroid(landscape)
dist(st_centroid(landscape))
centroids <- st_centroid(landscape)
centroid_dist <- st_distance(centroids[1, ], centroids[2, ])
View(centroid_dist)
centroids
neighbors <- st_nn(
x = centroids,
y = centroids,
k = 10^6,   # large number to get all within maxdist
maxdist = max_host_dispersal,
returnDist = TRUE,   # we want distances
progress = FALSE
)
neighbors <- st_nn(
x = centroids,
y = centroids,
k = n,   # large number to get all within maxdist
maxdist = max_host_dispersal,
returnDist = TRUE,   # we want distances
progress = FALSE
)
n <- nrow(landscape)
neighbors <- st_nn(
x = centroids,
y = centroids,
k = n,   # large number to get all within maxdist
maxdist = max_host_dispersal,
returnDist = TRUE,   # we want distances
progress = FALSE
)
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
View(centroid_dist)
View(avg_host_dispersal)
View(neighbors)
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
View(centroids)
View(D)
D
?sparseMatrix
source("code/mapping.R")
# Load an image as landscape
landscape <- load_landscape(
"images/blobs.png",
scale = 0.5,# Set scale <1 to shrink image
cellsize = 100) |> # set cellsize <8 to make a finer hex grid overlay
basic_habitat_quality(threshold = 0.5)
# Sparse distance matrix computation
compute_sparse_distance <- function(landscape,
avg_host_dispersal,
max_host_dispersal_mult = 1.1,
normalize_rows = TRUE)
{
n <- nrow(landscape) # number of cells
centroids <- st_centroid(landscape)
centroid_dist <- st_distance(centroids[1, ], centroids[2, ]) # distance between centroids (cellsize)
avg_host_dispersal <- avg_host_dispersal * centroid_dist
max_host_dispersal <- max_host_dispersal_mult * avg_host_dispersal # max dispersal distance
# Get neighbor coordinates and distances
neighbors <- st_nn(
x = centroids,
y = centroids,
k = n,   # large number to get all within maxdist
maxdist = max_host_dispersal,
returnDist = TRUE,   # we want distances
progress = FALSE
)
origins <- rep(1:n, lengths(neighbors$nn)) # origin indices
destinations <- unlist(neighbors$nn) # destination indices
neighbor_distances <- unlist(neighbors$dist) # distances
# assemble as sparse matrix
D <- sparseMatrix(i = origins,
j = destinations,
x = neighbor_distances,
dims = c(n, n))
return(D)
}
# Generate sparse dispersal kernel
K <- sparse_kernel(landscape,
avg_host_dispersal = 1,
max_host_dispersal_mult = 1.1,
normalize_rows = TRUE)
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
View(K)
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
View(D)
D
source("~/R/simulating-ftc-movement/code/debug_example.R")
visualise_landscape(landscape)
# Generate sparse dispersal kernel
D <- compute_sparse_distance(landscape,
avg_host_dispersal = 1,
max_host_dispersal_mult = 1.1,
normalize_rows = TRUE)
D
# Initialize host distribution
H <- rep(0, nrow(landscape))
H
H[c(5)] <- 1
H
# Disperse
H_next <- D %*% H
# Visualize
landscape$H <- as.numeric(H_next)
ggplot(landscape) +
geom_sf(aes(fill = H)) +
scale_fill_viridis_c() +
theme_void()
# Load an image as landscape
landscape <- load_landscape(
"images/blobs.png",
scale = 0.5,# Set scale <1 to shrink image
cellsize = 10) |> # set cellsize <8 to make a finer hex grid overlay
basic_habitat_quality(threshold = 0.5)
visualise_landscape(landscape)
# Generate sparse distance matrix
D <- compute_sparse_distance(landscape,
avg_host_dispersal = 1,
max_host_dispersal_mult = 1.1,
normalize_rows = TRUE)
D
D[1:100,1:100]
D[1:10,1:10]
D[1:10,10:20]
D[1:10,20:30]
D[1:10,30:40]
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
source("~/R/simulating-ftc-movement/code/temp_dispersal.R")
D
