neighbs <- compute_neighbors(landscape, max_host_dispersal)
# Compute neighbour distances
dists <- compute_sparse_distance(landscape, neighbs, max_host_dispersal)
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
stay_prob = 0.5, # probability of staying in cell
scale = 1, # drop-off scale
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
# Initialize density
H <- matrix(NA_real_, nrow = nrow(landscape), ncol = timesteps)
H[,1] <- 1
H[,1] <- H[,1] / sum(H[,1])
# Disperse
for (i in 2:timesteps) {
H[,i] <- disperse(
kernel = K,
density = H[,i-1],
survival = 1
)
}
visualise_landscape(landscape, density = H[,1])
}
visualise_landscape(landscape, density = H[,1])
visualise_landscape(landscape, density = H[,2])
visualise_landscape(landscape, density = H[,3])
visualise_landscape(landscape, density = H[,10])
timesteps <- 20
# Initialize density
H <- matrix(NA_real_, nrow = nrow(landscape), ncol = timesteps)
H[,1] <- 1
H[,1] <- H[,1] / sum(H[,1])
# Disperse
for (i in 2:timesteps) {
H[,i] <- disperse(
kernel = K,
density = H[,i-1],
survival = 1
)
}
visualise_landscape(landscape, density = H[,10])
visualise_landscape(landscape, density = H[,20])
source("~/R/simulating-ftc-movement/code/model.R")
# Compute neighbours
neighbs <- compute_neighbors(landscape, max_host_dispersal)
# Compute neighbour distances
dists <- compute_sparse_distance(landscape, neighbs, max_host_dispersal)
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
stay_prob = 0.5, # probability of staying in cell
scale = 1, # drop-off scale
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
Q[j]
j
source("~/R/simulating-ftc-movement/code/model.R")
timesteps <- 20
max_host_dispersal <- 2 # number of adjacent cells
beta <- 0.8 # habitat preference
# load landscape
landscape <- load_landscape("images/blobs.png", scale = 0.5, # Set scale <1 to shrink image
cellsize = 20) # set cellsize <8 to make a finer hex grid overlay
landscape <- basic_habitat_quality(landscape, threshold = 0.5) # set habitat quality threshold
landscape$Q <- ifelse(landscape$type == "high", 1, 0)
# Compute neighbours
neighbs <- compute_neighbors(landscape, max_host_dispersal)
# Compute neighbour distances
dists <- compute_sparse_distance(landscape, neighbs, max_host_dispersal)
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
stay_prob = 0.5, # probability of staying in cell
scale = 1, # drop-off scale
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
source("~/R/simulating-ftc-movement/code/model.R")
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
stay_prob = 0.5, # probability of staying in cell
scale = 1, # drop-off scale
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
# Compute neighbours
neighbs <- compute_neighbors(landscape, max_host_dispersal)
# Compute neighbour distances
dists <- compute_sparse_distance(landscape, neighbs, max_host_dispersal)
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
stay_prob = 0.5, # probability of staying in cell
scale = 1, # drop-off scale
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
# Initialize density
H <- matrix(NA_real_, nrow = nrow(landscape), ncol = timesteps)
H[,1] <- 1
H[,1] <- H[,1] / sum(H[,1])
# Disperse
for (i in 2:timesteps) {
H[,i] <- disperse(
kernel = K,
density = H[,i-1],
survival = 1
)
}
visualise_landscape(landscape, density = H[,20])
?ceiling
source("~/R/simulating-ftc-movement/code/model.R")
source("~/R/simulating-ftc-movement/code/model.R")
source("~/R/simulating-ftc-movement/code/model.R")
# Compute neighbours
neighbs <- compute_neighbors(landscape, max_host_dispersal)
source("~/R/simulating-ftc-movement/code/model.R")
source("~/R/simulating-ftc-movement/code/model.R")
source("~/R/simulating-ftc-movement/code/model.R")
source("~/R/simulating-ftc-movement/code/model.R")
source("code/mapping.R")
source("code/model.R")
{
timesteps <- 20
max_host_dispersal <- 2 # number of adjacent cells
beta <- 0.8 # habitat preference
# load landscape
landscape <- load_landscape("images/blobs.png", scale = 0.5, # Set scale <1 to shrink image
cellsize = 80) # set cellsize <8 to make a finer hex grid overlay
landscape <- basic_habitat_quality(landscape, threshold = 0.5) # set habitat quality threshold
landscape$Q <- ifelse(landscape$type == "high", 1, 0)
# Compute neighbours
neighbs <- compute_neighbors(landscape, max_host_dispersal)
# Compute neighbour distances
dists <- compute_sparse_distance(landscape, neighbs, max_host_dispersal)
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
stay_prob = 0.5, # probability of staying in cell
scale = 1, # drop-off scale
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
# Initialize density
H <- matrix(NA_real_, nrow = nrow(landscape), ncol = timesteps)
H[,1] <- 1
H[,1] <- H[,1] / sum(H[,1])
# Disperse
for (i in 2:timesteps) {
H[,i] <- disperse(
kernel = K,
density = H[,i-1],
survival = 1
)
}
visualise_landscape(landscape, density = H[,20])
}
source("~/R/simulating-ftc-movement/code/model.R")
{
timesteps <- 20
max_host_dispersal <- 1 # number of adjacent cells
scale <- 1 # drop-off probability
stay_prob <- 0.5  # probability of staying in cell
beta <- 0.8 # habitat preference
survival <- 0.4# dispersal survival rate
# load landscape
landscape <- load_landscape("images/blobs.png", scale = 0.5, # Set scale <1 to shrink image
cellsize = 80) # set cellsize <8 to make a finer hex grid overlay
landscape <- basic_habitat_quality(landscape, threshold = 0.5) # set habitat quality threshold
landscape$Q <- ifelse(landscape$type == "high", 1, 0)
# Compute neighbours
neighbs <- compute_neighbors(landscape, max_host_dispersal)
# Compute neighbour distances
dists <- compute_sparse_distance(landscape, neighbs, max_host_dispersal)
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
stay_prob, # probability of staying in cell
scale, # drop-off scale
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
# Initialize density
H <- matrix(NA_real_, nrow = nrow(landscape), ncol = timesteps)
H[,1] <- 1
H[,1] <- H[,1] / sum(H[,1])
# Disperse
for (i in 2:timesteps) {
H[,i] <- disperse(
kernel = K,
density = H[,i-1],
survival
)
}
visualise_landscape(landscape, density = H[,20])
}
H
{
timesteps <- 20
max_host_dispersal <- 1 # number of adjacent cells
scale <- 1 # drop-off probability
stay_prob <- 0.5  # probability of staying in cell
beta <- 0.8 # habitat preference
survival <- 0.9# dispersal survival rate
# load landscape
landscape <- load_landscape("images/blobs.png", scale = 0.5, # Set scale <1 to shrink image
cellsize = 80) # set cellsize <8 to make a finer hex grid overlay
landscape <- basic_habitat_quality(landscape, threshold = 0.5) # set habitat quality threshold
landscape$Q <- ifelse(landscape$type == "high", 1, 0)
# Compute neighbours
neighbs <- compute_neighbors(landscape, max_host_dispersal)
# Compute neighbour distances
dists <- compute_sparse_distance(landscape, neighbs, max_host_dispersal)
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
stay_prob, # probability of staying in cell
scale, # drop-off scale
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
# Initialize density
H <- matrix(NA_real_, nrow = nrow(landscape), ncol = timesteps)
H[,1] <- 1
H[,1] <- H[,1] / sum(H[,1])
# Disperse
for (i in 2:timesteps) {
H[,i] <- disperse(
kernel = K,
density = H[,i-1],
survival
)
}
visualise_landscape(landscape, density = H[,20])
}
H
{
timesteps <- 20
max_host_dispersal <- 1 # number of adjacent cells
scale <- 1 # drop-off probability
stay_prob <- 0.5  # probability of staying in cell
beta <- 0.8 # habitat preference
survival <- 1# dispersal survival rate
# load landscape
landscape <- load_landscape("images/blobs.png", scale = 0.5, # Set scale <1 to shrink image
cellsize = 80) # set cellsize <8 to make a finer hex grid overlay
landscape <- basic_habitat_quality(landscape, threshold = 0.5) # set habitat quality threshold
landscape$Q <- ifelse(landscape$type == "high", 1, 0)
# Compute neighbours
neighbs <- compute_neighbors(landscape, max_host_dispersal)
# Compute neighbour distances
dists <- compute_sparse_distance(landscape, neighbs, max_host_dispersal)
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
stay_prob, # probability of staying in cell
scale, # drop-off scale
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
# Initialize density
H <- matrix(NA_real_, nrow = nrow(landscape), ncol = timesteps)
H[,1] <- 1
H[,1] <- H[,1] / sum(H[,1])
# Disperse
for (i in 2:timesteps) {
H[,i] <- disperse(
kernel = K,
density = H[,i-1],
survival
)
}
visualise_landscape(landscape, density = H[,20])
}
H
View(landscape)
{
timesteps <- 20
max_host_dispersal <- 1 # number of adjacent cells
scale <- 1 # drop-off probability
stay_prob <- 0.5  # probability of staying in cell
beta <- 0.8 # habitat preference
survival <- 1# dispersal survival rate
# load landscape
landscape <- load_landscape("images/blobs.png", scale = 0.5, # Set scale <1 to shrink image
cellsize = 80) # set cellsize <8 to make a finer hex grid overlay
landscape <- basic_habitat_quality(landscape, threshold = 0.5) # set habitat quality threshold
landscape$Q <- ifelse(landscape$type == "high", 1, 0)
# Compute neighbours
neighbs <- compute_neighbors(landscape, max_host_dispersal)
# Compute neighbour distances
dists <- compute_sparse_distance(landscape, neighbs, max_host_dispersal)
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
stay_prob, # probability of staying in cell
scale, # drop-off scale
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
# Initialize density
H <- matrix(NA_real_, nrow = nrow(landscape), ncol = timesteps)
H[,1] <- 1
H[,1] <- H[,1] / sum(H[,1])
# Disperse
for (i in 2:timesteps) {
H[,i] <- disperse(
kernel = K,
density = H[,i-1],
survival
)
}
visualise_landscape(landscape, density = H[,20])
}
H
# Initialize density
H <- matrix(NA_real_, nrow = nrow(landscape), ncol = timesteps)
H[,1] <- 1
H[,1] <- H[,1] / sum(H[,1])
H
# Disperse
for (i in 2:timesteps) {
H[,i] <- disperse(
kernel = K,
density = H[,i-1],
survival
)
}
visualise_landscape(landscape, density = H[,20])
H
landscape
{
timesteps <- 20
max_host_dispersal <- 2 # number of adjacent cells
scale <- 1 # drop-off probability
stay_prob <- 0.5  # probability of staying in cell
beta <- 0.8 # habitat preference
survival <- 1 # dispersal survival rate
# load landscape
landscape <- load_landscape("images/blobs.png", scale = 0.5, # Set scale <1 to shrink image
cellsize = 80) # set cellsize <8 to make a finer hex grid overlay
landscape <- basic_habitat_quality(landscape, threshold = 0.5) # set habitat quality threshold
landscape$Q <- ifelse(landscape$type == "high", 1, 0)
# Compute neighbours
neighbs <- compute_neighbors(landscape, max_host_dispersal)
# Compute neighbour distances
dists <- compute_sparse_distance(landscape, neighbs, max_host_dispersal)
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
stay_prob, # probability of staying in cell
scale, # drop-off scale
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
# Initialize density
H <- matrix(NA_real_, nrow = nrow(landscape), ncol = timesteps)
H[,1] <- 1
H[,1] <- H[,1] / sum(H[,1])
# Disperse
for (i in 2:timesteps) {
H[,i] <- disperse(
kernel = K,
density = H[,i-1],
survival
)
}
visualise_landscape(landscape, density = H[,20])
}
H
{
timesteps <- 20
max_host_dispersal <- 2 # number of adjacent cells
scale <- 1 # drop-off strength
stay_prob <- 0.5  # probability of staying in cell
beta <- 2 # habitat preference
survival <- 1 # dispersal survival rate
# load landscape
landscape <- load_landscape("images/blobs.png", scale = 0.5, # Set scale <1 to shrink image
cellsize = 80) # set cellsize <8 to make a finer hex grid overlay
landscape <- basic_habitat_quality(landscape, threshold = 0.5) # set habitat quality threshold
landscape$Q <- ifelse(landscape$type == "high", 1, 0)
# Compute neighbours
neighbs <- compute_neighbors(landscape, max_host_dispersal)
# Compute neighbour distances
dists <- compute_sparse_distance(landscape, neighbs, max_host_dispersal)
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
stay_prob, # probability of staying in cell
scale, # drop-off scale
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
# Initialize density
H <- matrix(NA_real_, nrow = nrow(landscape), ncol = timesteps)
H[,1] <- 1
H[,1] <- H[,1] / sum(H[,1])
# Disperse
for (i in 2:timesteps) {
H[,i] <- disperse(
kernel = K,
density = H[,i-1],
survival
)
}
visualise_landscape(landscape, density = H[,20])
}
H
K
stay_prob <- 0.5  # probability of staying in cell
source("code/mapping.R")
source("code/model.R")
{
timesteps <- 20
max_host_dispersal <- 2 # number of adjacent cells
scale <- 1 # drop-off strength
stay_prob <- 0.5  # probability of staying in cell
beta <- 0.8 # habitat preference
survival <- 1 # dispersal survival rate
# load landscape
landscape <- load_landscape("images/blobs.png", scale = 0.5, # Set scale <1 to shrink image
cellsize = 80) # set cellsize <8 to make a finer hex grid overlay
landscape <- basic_habitat_quality(landscape, threshold = 0.5) # set habitat quality threshold
landscape$Q <- ifelse(landscape$type == "high", 1, 0)
# Compute neighbours
neighbs <- compute_neighbors(landscape, max_host_dispersal)
# Compute neighbour distances
dists <- compute_sparse_distance(landscape, neighbs, max_host_dispersal)
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
stay_prob, # probability of staying in cell
scale, # drop-off scale
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
# Initialize density
H <- matrix(NA_real_, nrow = nrow(landscape), ncol = timesteps)
H[,1] <- 1
H[,1] <- H[,1] / sum(H[,1])
# Disperse
for (i in 2:timesteps) {
H[,i] <- disperse(
kernel = K,
density = H[,i-1],
survival
)
}
visualise_landscape(landscape, density = H[,20])
}
View(K)
K
dists
neighbs
dists
{
timesteps <- 20
max_host_dispersal <- 2 # number of adjacent cells
scale <- 1 # drop-off strength
stay_prob <- 0.5  # probability of staying in cell
beta <- 0.8 # habitat preference
survival <- 1 # dispersal survival rate
# load landscape
landscape <- load_landscape("images/blobs.png", scale = 0.5, # Set scale <1 to shrink image
cellsize = 80) # set cellsize <8 to make a finer hex grid overlay
landscape <- basic_habitat_quality(landscape, threshold = 0.5) # set habitat quality threshold
landscape$Q <- ifelse(landscape$type == "high", 1, 0)
# Compute neighbours
neighbs <- compute_neighbors(landscape, max_host_dispersal)
# Compute neighbour distances
dists <- compute_sparse_distance(landscape, neighbs, max_host_dispersal)
# Generate dispersal kernel
K <- initialize_dispersal(
dists, # sparse distance matrix
scale, # drop-off scale
stay_prob, # probability of staying in cell
kernel_function = "negative_exp",
beta, # habitat preference strength
Q = landscape$Q # habitat quality vector
)
# Initialize density
H <- matrix(NA_real_, nrow = nrow(landscape), ncol = timesteps)
H[,1] <- 1
H[,1] <- H[,1] / sum(H[,1])
# Disperse
for (i in 2:timesteps) {
H[,i] <- disperse(
kernel = K,
density = H[,i-1],
survival
)
}
visualise_landscape(landscape, density = H[,20])
}
